% -*- mode: noweb; noweb-default-code-mode: R-mode; -*-
%\VignetteIndexEntry{Test background correction for Kim}

\documentclass{article}
\usepackage{amsmath,pstricks}
\usepackage{hyperref}
\usepackage[authoryear,round]{natbib}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\textit{#1}}}

\SweaveOpts{keep.source=TRUE}
\begin{document}
\setkeys{Gin}{width=0.8\textwidth} 
\author{Tim Triche, Jr.}
\title{HM27k Background correction with methylumIDAT and rGammaGamma}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Importing and molding data}

\section{Creating a MethyLumiSet from IDATs}
Load ten not-so-identical datasets corresponding to ten identical blood samples:

<<load TMM replicates, eval=T>>=
library(methylumi)
library(methylumIDAT) # this will go away
barcodes <- c("4760681003_A","4760681003_L","4760681035_A","4760681035_L","4763072035_A","4763072035_L","4763072073_A","4763072073_L","4763072082_A","4763072082_L")
TMM <- methylumIDAT(barcodes)
TMM$chip <- as.factor(substr(sampleNames(TMM), 1, 10))
TMM$slot <- as.factor(substr(sampleNames(TMM), 12, 12))
show(TMM)
sampleNAs(TMM) # note: there will be more NAs in methylumIDAT 1.0.17 and later 
sum(sampleNAs(TMM)) # the reason is that newer versions use the ECDF for pvals
@ 

\begin{figure}[h!]
\centering
<<TmmBetas, fig=T, eval=T>>=
hist(betas(TMM))
@
\caption{TMM beta values}
\label{fig:betavals}
\end{figure}            

The histogram should have endpoints at 0 and 1.

\clearpage

\section{Coercing to MethyLumiM}
We can either go straight to lumi by using lumIDAT(barcodes), or coerce it:
 
<<coercing to Lumi, eval=T>>=
library(lumi)
TMM.lumi <- as(TMM, 'MethyLumiM')
show(TMM.lumi)
@ 
\clearpage
 
\begin{figure}[h!]
\centering
<<correps, fig=T, width=6.5, height=6.5, quiet=T, echo=T>>=
pairs(TMM.lumi)
@
\caption{M-value correlation between TMM replicates}
\label{fig:correps}
\end{figure}            

The pair plot indicates less-than-stellar correlation.

\clearpage

\section{Comparison}
Compare one array between data structures to catch any changes:
\begin{figure}[h!]
\centering
<<comparison, fig=T, width=8, height=4, echo=F>>=
par(mfrow=c(1,3))
hist(assayDataElement(TMM[,1],'betas'),xlab='Beta values',main='TMM')
hist(betas(TMM.lumi)[,1], xlab='Beta values', main='TMM.lumi')
hist(exprs(TMM.lumi)[,1], xlab='M values', main='TMM.lumi')
@
\caption{Beta values vs. lumi Betas vs. lumi M-values}
\label{fig:comparison}
\end{figure}            
\clearpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Correction of artifacts}

\section{Control probes}
The control probes will tell us a lot about how much preprocessing we need.
In this case, we have replicates on the far left and right slots of each chip.

\begin{figure}[h!]
\centering
<<controls, fig=T, width=6.5, height=6.5, quiet=T, echo=T>>=
print(qc.probe.plot(TMM, 'negnorm'))
@
\caption{Control probes}
\label{fig:controlplot}
\end{figure}            
\clearpage

\section{Lumi-style background correction}

This is the 'lumi' method of Lin and Du as described in my chapter.   In order
to force lumi to use the empirical background estimation method derived from 
the histogram of the methylated intensities, we have to remove the control probe
information, else it will default to subtracting the median negative control 
probe intensity (which works pretty well and is what Illumina does on the 450s).

<<lumi bgcorr, eval=T>>=
TMM.lumi.noctls <- TMM.lumi
TMM.lumi.noctls@controlData <- NULL # force the issue
TMM.lumi.bg <- lumiMethyB(TMM.lumi.noctls, separateColor=T, target=50)
@ 

We expect the distribution of beta values to be a little more extreme and it is:

\begin{figure}[h!]
\centering
<<TmmMvalues, fig=T, eval=T>>=
hist(betas(TMM.lumi.bg))
@
\caption{TMM m-values}
\label{fig:mvals}
\end{figure}            

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Normal-exponential convolution}

This is the normal-exponential convolution as implemented in 'limma'.

<<normexp, eval=T, fig=T>>=
TMM.nexp = mcsv.normexp(TMM, offset=50)
par(mfrow=c(1,2))
hist(betas(TMM), main='before normexp')
hist(betas(TMM.nexp), main='after normexp')
@ 

\clearpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Gamma-Gamma convolution}

This is the Gamma convolution as implemented in gamma.conditional(), using the
negative control probes to estimate the background intensity distribution.  It's
probably OK to do this on the 450k chips, but on the sort of chips that actually
benefit most from background correction, especially on the 27k platform, it's 
a better idea to use the mixture model and take advantage of more data points.

<<gammactl, eval=T, fig=T>>=
source("~/Dropbox/rGammaGamma/rGammaGamma/R/gammamix.R")
## TMM.ctl = gamma.ctl(TMM, offset=50)
load("~/Dropbox/Kim/TMM.ctl.rda")
par(mfrow=c(1,2))
hist(betas(TMM), main='before gammactl')
hist(betas(TMM.ctl), main='after gammactl')
@ 

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Gamma mixture deconvolution}

This is the 85/15 mixture model described in my chapter. The idea is to estimate
the non-specific fluorescence intensity from the methylated intensities at the 
low end of the beta value scale, borrowing an idea from Du and Lin, but then 
perform a Gamma deconvolution on the signal intensities in each channel using
this estimate, which borrows from the Normal-Exponential convolution and its 
success on expression microarrays.  Nonspecific (background) estimates:

<<nonspecific, eval=T, echo=T>>=
## library(rGammaGamma)
source("~/Dropbox/rGammaGamma/rGammaGamma/R/gammamix.R")
head(gamma.nonspecific(TMM))
@ 

Specific (foreground, per-channel, per-allele) estimates:

<<specific, eval=T, echo=T>>=
head(gamma.specific(TMM))
@ 

Corrected intensities, 1000 probes (otherwise very slow):
<<gammamix, eval=T, fig=T>>=
## TMM.mix = gamma.mix(TMM[1000:2000,], offset=50)
load("~/Dropbox/Kim/TMM.mix.rda")
par(mfrow=c(1,2))
hist(betas(TMM), main='before gammamix')
hist(betas(TMM.mix), main='after gammamix')
@ 

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Comparison of results}

To determine which method makes the most sense in general, we look at the 
probe-level standard deviation across ten identical whole blood replicates, 
from five BeadChips with significant positional artifacts. 

<<probeSDs, eval=T, echo=T>>=
method.name = function(x) strsplit(x, '\\.')[[1]][1]
TMMs = list(raw=TMM, lumi=TMM.lumi.bg, normexp=TMM.nexp, 
            gammactl=TMM.ctl, gammamix=TMM.mix) 
TMM.SD.both = data.frame(SD=unlist(lapply(TMMs, function(x) rowSds(betas(x)))))
TMM.SD.Cy5 = data.frame(
                SD=unlist(lapply(TMMs, function(x) rowSds(betas(x)[cy5(x),]))))
TMM.SD.Cy3 = data.frame(
                SD=unlist(lapply(TMMs, function(x) rowSds(betas(x)[cy3(x),]))))
TMM.SD.both$method = as.factor(sapply(rownames(TMM.SD.both), method.name))
TMM.SD.Cy5$method = as.factor(sapply(rownames(TMM.SD.Cy5), method.name))
TMM.SD.Cy3$method = as.factor(sapply(rownames(TMM.SD.Cy3), method.name))
TMM.SD.both$channel = 'both'
TMM.SD.Cy5$channel = 'Cy5'
TMM.SD.Cy3$channel = 'Cy3'
TMM.SDs = rbind(TMM.SD.both, TMM.SD.Cy5, TMM.SD.Cy3)
p = qplot(data=TMM.SDs, geom='boxplot', y=SD, x=method, fill=method, 
          main='Background correction and probe-level SD', facets=.~channel) +
          scale_y_log10() + theme_bw()
@ 

\begin{figure}[h!]
\centering
<<probeLevelSDs, fig=T, eval=T>>=
print(p)
@
\caption{probe-level standard deviations
\label{fig:probeSDs}
\end{figure}            
\clearpage

The gamma mixture model clearly outperforms the other methods, with the 
empirical method from Lumi and the Gamma deconvolution on controls trailing. 
The normal-exponential convolution is scarcely better than doing nothing.
\\
All of the methods described in this vignette are available from the R packages
'lumi', 'methylumi' (release 2.8 and later), or 'rGammaGamma' (TBA, on CRAN).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{sessionInfo}
<<results=tex>>=
toLatex(sessionInfo())
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
